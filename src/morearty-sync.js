// Generated by CoffeeScript 1.8.0
var B, Binding, History, Imm, Morearty, MoreartySync, SyncCollection, SyncModel, defaultSync, isEmptyObject, validateModel,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

B = require('backbone');

Imm = require('immutable');

Morearty = require('morearty');

Binding = Morearty.Binding, History = Morearty.History;

defaultSync = B.sync;

isEmptyObject = function(obj) {
  return Object.getOwnPropertyNames(obj).length === 0;
};

B.sync = function(method, model, options) {
  var xhr;
  if (options == null) {
    options = {};
  }
  xhr = defaultSync(method, model, options);
  if (model instanceof SyncModel) {
    model.set('status', method);
    return xhr.success(function() {
      return model.unsetIfExists('error');
    }).fail(function(e, error, errorMessage) {
      var _ref;
      if (options.rollback) {
        if ((_ref = model.history) != null) {
          _ref.undo();
        }
      }
      return model.set('error', Imm.fromJS(errorMessage || 'Unknown error'));
    }).always(function() {
      return model.unset('status');
    });
  }
};

validateModel = function(ModelOrCollectionClass, BaseClass, type) {
  if (ModelOrCollectionClass !== BaseClass) {
    if (!(ModelOrCollectionClass.prototype instanceof BaseClass)) {
      throw new Error("" + type + " should be instance of " + BaseClass.name);
    }
  }
};

SyncModel = (function(_super) {
  __extends(SyncModel, _super);


  /*
  @param {Binding|Object} data - representing the model data. For raw object new binding will be created.
   */

  function SyncModel(data) {
    this.binding = data instanceof Binding ? data : Binding.init(Imm.fromJS(data));
    SyncModel.__super__.constructor.call(this, null);
    this._historyBinding = Binding.init();
    this.history = History.init(this.binding, this._historyBinding);
    Object.defineProperty(this, 'id', {
      writeable: false,
      get: function() {
        return function() {
          return this.get(this.idAttribute || 'id');
        };
      }
    });
    Object.defineProperty(this, 'url', {
      writeable: false,
      get: function() {
        return function() {
          var url;
          url = B.Model.prototype.url.call(this);
          if (this.isNew()) {
            return url;
          } else {
            return url.replace(/(.*)\/.*/, "$1/" + (encodeURIComponent(this.id())));
          }
        };
      }
    });
  }

  SyncModel.prototype.get = function(key) {
    var value;
    value = this.binding.val(key);
    if (value instanceof Imm.Sequence) {
      return value.toJSON();
    } else {
      return value;
    }
  };

  SyncModel.prototype.set = function(key, val, options) {
    var attrs, k, tx, validationError, _ref;
    if (!key) {
      return this;
    }
    _ref = this._attrsAndOptions(key, val, options), attrs = _ref.attrs, options = _ref.options;
    if (isEmptyObject(attrs)) {
      return;
    }
    if (options.unset) {
      tx = this.binding.atomically();
      for (k in attrs) {
        tx = tx["delete"](k);
      }
      tx.commit(options.silent);
    } else {
      this.binding.merge(Imm.fromJS(attrs));
    }
    validationError = typeof this.validate === "function" ? this.validate(this.toJSON()) : void 0;
    if (validationError) {
      this.binding.set('validationError', Imm.fromJS(validationError));
    } else {
      this.unsetIfExists('validationError');
    }
    return this;
  };

  SyncModel.prototype.toJSON = function() {
    var json, k, _i, _len, _ref;
    json = this.binding.val().toJSON();
    _ref = ['status', 'validationError'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      delete json[k];
    }
    return json;
  };

  SyncModel.prototype.unsetIfExists = function(key) {
    if (this.get(key)) {
      return this.unset(key);
    }
  };

  SyncModel.prototype._attrsAndOptions = function(key, val, options) {
    var attrs;
    attrs = {};
    if (typeof key === 'object') {
      attrs = key;
      options = val;
    } else {
      attrs[key] = val;
    }
    return {
      attrs: attrs,
      options: options || {}
    };
  };

  return SyncModel;

})(B.Model);

SyncCollection = (function(_super) {
  __extends(SyncCollection, _super);

  SyncCollection.prototype.model = SyncModel;

  function SyncCollection(vectorBinding, options) {
    this.vectorBinding = vectorBinding;
    if (options == null) {
      options = {};
    }
    if (!this.vectorBinding instanceof Binding) {
      throw new Error('Pass Binding instance as a first argument');
    }
    validateModel(this.model, SyncModel, 'model');
    SyncCollection.__super__.constructor.call(this, this.extractModelBindings());
    this._syncWithBinding();
  }

  SyncCollection.prototype._syncWithBinding = function() {
    this.vectorBinding.addGlobalListener((function(_this) {
      return function(_, __, absolutePath, relativePath) {
        if (!relativePath) {
          return _this._updateModels();
        }
      };
    })(this));
    this.listenTo(this, 'add', (function(_this) {
      return function(model, collection, options) {
        return _this._onAdd(model, options);
      };
    })(this));
    this.listenTo(this, 'remove', function(model, collection, options) {
      return this._onRemove(model, options);
    });
    return this.listenTo(this, 'reset', function(collection, options) {
      return this._onReset(options);
    });
  };

  SyncCollection.prototype.extractModelBindings = function() {
    var _i, _ref, _results;
    return (function() {
      _results = [];
      for (var _i = 0, _ref = this.vectorBinding.val().length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map((function(_this) {
      return function(i) {
        return _this.vectorBinding.sub(i);
      };
    })(this));
  };

  SyncCollection.prototype._onAdd = function(models, options) {
    var at, immData;
    immData = this._modelsToVector(models);
    at = options.at;
    return this.vectorBinding.update(function(v) {
      var args;
      if (at != null) {
        args = [at, 0].concat(immData);
        return v.splice.apply(v, args);
      } else {
        return v.concat(immData);
      }
    });
  };

  SyncCollection.prototype._onReset = function(options) {
    var v;
    v = this._modelsToVector(this.models);
    return this.vectorBinding.set(v);
  };

  SyncCollection.prototype._onRemove = function(model, options) {
    return this.vectorBinding.update(function(v) {
      return v.splice(options.index, 1);
    });
  };

  SyncCollection.prototype._modelsToVector = function(models) {
    return [].concat(models).map(function(model) {
      return model.binding.val();
    });
  };

  SyncCollection.prototype._updateModels = function() {
    return this.models.forEach((function(_this) {
      return function(model, i) {
        var vItemBinding, _ref;
        model.updateId();
        vItemBinding = _this.vectorBinding.sub(i);
        if (model.binding !== vItemBinding) {
          model.binding = vItemBinding;
          return (_ref = model.history) != null ? _ref.clear() : void 0;
        }
      };
    })(this));
  };

  return SyncCollection;

})(B.Collection);

MoreartySync = {
  SyncModel: SyncModel,
  SyncCollection: SyncCollection,
  createContext: function(_arg) {
    var Ctx, ModelOrCollection, binding, configuration, mapping, modelMapping, path, state, _i, _len;
    state = _arg.state, modelMapping = _arg.modelMapping, configuration = _arg.configuration;
    Ctx = Morearty.createContext(state, configuration);
    Ctx._modelMap = {};
    Ctx._modelMapRegExps = [];
    for (_i = 0, _len = modelMapping.length; _i < _len; _i++) {
      mapping = modelMapping[_i];
      path = mapping.path, ModelOrCollection = mapping.ModelOrCollection;
      binding = Ctx.getBinding().sub(path);
      if (path instanceof RegExp) {
        Ctx._modelMapRegExps.push({
          pathRegExp: path,
          model: ModelOrCollection
        });
      } else {
        Ctx._modelMap[path] = new ModelOrCollection(binding);
      }
    }
    return Ctx;
  },
  Mixin: {
    model: function(binding) {
      var MClass, collection, ctx, itemIndex, m, matched, model, path, vectorPath, _ref;
      if (binding == null) {
        binding = this.getDefaultBinding();
      }
      ctx = this.context.morearty;
      path = Binding.asStringPath(binding._path);
      return model = (m = ctx._modelMap[path]) ? m : (matched = path.match(/(.*)\.(\d+)/)) ? (vectorPath = matched[1], itemIndex = matched[2], collection = ctx._modelMap[vectorPath], model = collection != null ? collection.at(itemIndex) : void 0) : (MClass = (_ref = (ctx._modelMapRegExps.filter(function(rx) {
        return path.match(rx.pathRegExp);
      }))[0]) != null ? _ref.model : void 0, MClass ? new MClass(binding) : void 0);
    },
    collection: function(binding) {
      return this.model(binding);
    }
  }
};

module.exports = MoreartySync;
