// Generated by CoffeeScript 1.8.0
(function() {
  var B, Binding, History, Imm, Morearty, MoreartySync, SyncCollection, SyncModel, defaultSync, linkBinding, statusMap, validateModel, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('lodash');

  B = require('backbone');

  Imm = require('immutable');

  Morearty = require('morearty');

  Binding = Morearty.Binding, History = Morearty.History;

  linkBinding = Morearty.Callback.set;

  defaultSync = B.sync;

  statusMap = {
    'create': 'creating',
    'update': 'updating',
    'patch': 'patching',
    'delete': 'deleting',
    'read': 'reading'
  };

  B.sync = function(method, model, options) {
    var xhr;
    this.options = options != null ? options : {};
    xhr = defaultSync(method, model, options);
    if (model instanceof SyncModel) {
      model.setStatus('xhr', statusMap[method]);
      return xhr.success(function() {
        return model.unsetStatus('error');
      }).fail(function(e, error, errorMessage) {
        var _ref;
        if (options.rollback) {
          if ((_ref = model.history) != null) {
            _ref.undo();
          }
        }
        return model.setStatus('error', Imm.fromJS(errorMessage || 'Unknown error'));
      }).always(function() {
        return model.unsetStatus('xhr');
      });
    }
  };

  validateModel = function(ModelOrCollectionClass, BaseClass, type) {
    if (ModelOrCollectionClass !== BaseClass) {
      if (!(ModelOrCollectionClass.prototype instanceof BaseClass)) {
        throw new Error("" + type + " should be instance of " + BaseClass.name);
      }
    }
  };

  SyncModel = (function(_super) {
    __extends(SyncModel, _super);


    /*
    @param {Binding|Object} data - representing the model data. For raw object new binding will be created.
     */

    function SyncModel(data, options) {
      var defaults;
      if (options == null) {
        options = {};
      }
      defaults = {
        trackStatus: true
      };
      this.options = _.extend(defaults, options);
      this.binding = data instanceof Binding ? data : (this.options.parse ? data = this.parse(data, this.options) || {} : void 0, Binding.init(Imm.fromJS(data)));
      this.modelStatusBinding = this.binding.sub('__model_status');
      this._historyBinding = Binding.init();
      this.history = History.init(this.binding, this._historyBinding);
      Object.defineProperties(this, {
        'id': {
          writeable: false,
          get: function() {
            return this.get(this.idAttribute || 'id');
          },
          set: function(id) {
            return this.set(this.idAttribute || 'id', id);
          }
        }
      });
      this.initialize.apply(this, arguments);
    }

    SyncModel.prototype.get = function(key) {
      return this.binding.toJS(key);
    };

    SyncModel.prototype.set = function(key, val, options) {
      var attrs, k, tx, validationError, _ref;
      if (!key) {
        return this;
      }
      _ref = this._attrsAndOptions(key, val, options), attrs = _ref.attrs, options = _ref.options;
      if (_.isEmpty(attrs)) {
        return;
      }
      tx = this.binding.atomically();
      if (options.unset) {
        for (k in attrs) {
          tx["delete"](k);
        }
      } else {
        tx.merge(Imm.fromJS(attrs));
      }
      validationError = typeof this.validate === "function" ? this.validate(this.toJSON()) : void 0;
      if (validationError) {
        this.setStatus('validationError', Imm.fromJS(validationError), tx);
      } else {
        this.unsetStatus('validationError', tx);
      }
      tx.commit(options.silent);
      return this;
    };

    SyncModel.prototype.toJSON = function() {
      return this.getCleanState().toJS();
    };

    SyncModel.prototype.unsetIfExists = function(key) {
      if (this.get(key)) {
        return this.unset(key);
      }
    };

    SyncModel.prototype.bindTo = function(newBinding) {
      newBinding.set(this.binding.val());
      return this.binding = newBinding;
    };

    SyncModel.prototype.isPending = function() {
      return this.getStatus('xhr');
    };

    SyncModel.prototype.setStatus = function(key, status, tx) {
      if (this.options.trackStatus) {
        return this._wrapTx(this.modelStatusBinding, 'set', key, status, tx);
      }
    };

    SyncModel.prototype.unsetStatus = function(key, tx) {
      return this._wrapTx(this.modelStatusBinding, 'delete', key, tx);
    };

    SyncModel.prototype.getStatus = function(key) {
      return this.modelStatusBinding.val(key);
    };

    SyncModel.prototype.getCleanState = function(state) {
      if (state == null) {
        state = this.binding.val();
      }
      return state["delete"]('__model_status');
    };

    SyncModel.prototype._wrapTx = function(binding, method, key, value, tx) {
      if (tx) {
        return tx[method](key, binding, value);
      } else {
        return binding[method](key, value);
      }
    };

    SyncModel.prototype._attrsAndOptions = function(key, val, options) {
      var attrs;
      attrs = {};
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        attrs[key] = val;
      }
      return {
        attrs: attrs,
        options: options || {}
      };
    };

    return SyncModel;

  })(B.Model);


  /*
  !!! WARNING !!!
  Don't use this. I will come up with a better solution later.
  For now it is broken by design and implementation.
   */

  SyncCollection = (function(_super) {
    __extends(SyncCollection, _super);

    SyncCollection.prototype.model = SyncModel;

    function SyncCollection(vectorBinding, options) {
      this.vectorBinding = vectorBinding;
      if (options == null) {
        options = {};
      }
      if (!this.vectorBinding instanceof Binding) {
        throw new Error('Pass Binding instance as a first argument');
      }
      validateModel(this.model, SyncModel, 'model');
      SyncCollection.__super__.constructor.call(this, this.extractModelBindings());
      this._syncWithBinding();
    }

    SyncCollection.prototype._syncWithBinding = function() {
      this.vectorBinding.addGlobalListener((function(_this) {
        return function(_, __, absolutePath, relativePath) {
          if (!relativePath) {
            return _this._updateModels();
          }
        };
      })(this));
      this.listenTo(this, 'add', (function(_this) {
        return function(model, collection, options) {
          return _this._onAdd(model, options);
        };
      })(this));
      this.listenTo(this, 'remove', function(model, collection, options) {
        return this._onRemove(model, options);
      });
      return this.listenTo(this, 'reset', function(collection, options) {
        return this._onReset(options);
      });
    };

    SyncCollection.prototype.extractModelBindings = function() {
      var _i, _ref, _results;
      return (function() {
        _results = [];
        for (var _i = 0, _ref = this.vectorBinding.val().length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map((function(_this) {
        return function(i) {
          return _this.vectorBinding.sub(i);
        };
      })(this));
    };

    SyncCollection.prototype._onAdd = function(models, options) {
      var at, immData;
      immData = this._modelsToVector(models);
      at = options.at;
      return this.vectorBinding.update(function(v) {
        var args;
        if (at != null) {
          args = [at, 0].concat(immData);
          return v.splice.apply(v, args);
        } else {
          return v.concat(immData);
        }
      });
    };

    SyncCollection.prototype._onReset = function(options) {
      var v;
      v = this._modelsToVector(this.models);
      return this.vectorBinding.set(v);
    };

    SyncCollection.prototype._onRemove = function(model, options) {
      return this.vectorBinding.update(function(v) {
        return v.splice(options.index, 1);
      });
    };

    SyncCollection.prototype._modelsToVector = function(models) {
      return [].concat(models).map(function(model) {
        return model.binding.val();
      });
    };

    SyncCollection.prototype._updateModels = function() {
      return this.models.forEach((function(_this) {
        return function(model, i) {
          var vItemBinding, _ref;
          model.updateId();
          vItemBinding = _this.vectorBinding.sub(i);
          if (model.binding !== vItemBinding) {
            model.binding = vItemBinding;
            return (_ref = model.history) != null ? _ref.clear() : void 0;
          }
        };
      })(this));
    };

    return SyncCollection;

  })(B.Collection);

  MoreartySync = {
    SyncModel: SyncModel,
    SyncCollection: SyncCollection,
    createContext: function(_arg) {
      var Ctx, ModelOrCollection, configuration, model, modelMapping, path, state, _i, _len, _ref;
      state = _arg.state, modelMapping = _arg.modelMapping, configuration = _arg.configuration;
      Ctx = Morearty.createContext(state, configuration);
      Ctx._modelMap = {};
      Ctx._modelMapRegExps = [];
      Ctx._modelInstances = {};
      for (_i = 0, _len = modelMapping.length; _i < _len; _i++) {
        _ref = modelMapping[_i], path = _ref.path, model = _ref.model;
        ModelOrCollection = model;
        if (path instanceof RegExp) {
          Ctx._modelMapRegExps.push({
            pathRegExp: path,
            model: ModelOrCollection
          });
        } else {
          Ctx._modelMap[path] = ModelOrCollection;
        }
      }
      return Ctx;
    },
    Mixin: {
      model: function(binding) {
        var MClass, ModelOrCollection, collection, ctx, itemIndex, m, matched, model, path, vectorPath, __, _ref;
        if (binding == null) {
          binding = this.getDefaultBinding();
        }
        ctx = this.context.morearty;
        path = Binding.asStringPath(binding._path);
        return model = (m = ctx._modelInstances[path]) ? m : (ModelOrCollection = ctx._modelMap[path]) ? ctx._modelInstances[path] = new ModelOrCollection(binding) : (matched = path.match(/(.*)\.(\d+)/)) ? ((__ = matched[0], vectorPath = matched[1], itemIndex = matched[2], matched), collection = ctx._modelMap[vectorPath], model = collection != null ? collection.at(itemIndex) : void 0) : (MClass = (_ref = (ctx._modelMapRegExps.filter(function(rx) {
          return path.match(rx.pathRegExp);
        }))[0]) != null ? _ref.model : void 0, MClass ? ctx._modelInstances[path] = new MClass(binding) : void 0);
      },
      collection: function(binding) {
        return this.model(binding);
      },
      linkModel: function(model, path, throughFn) {
        if (throughFn == null) {
          throughFn = _.identity;
        }
        return linkBinding(model.binding, path, _.compose(throughFn, _.partial(this._beforeModelEdit, model)));
      },
      _beforeModelEdit: function(model, value) {
        model.setStatus('saved', false);
        return value;
      }
    },
    BranchMixin: {
      componentWillMount: function() {
        return this.fork();
      },
      componentWillUnmount: function() {
        return this.revert();
      },
      fork: function() {
        var model;
        model = this.model();
        return model._stateBeforeEdit = model.binding.val();
      },
      revert: function() {
        var model;
        model = this.model();
        if (!model.getStatus('saved')) {
          return model.binding.set(model._stateBeforeEdit);
        }
      },
      saveAndMerge: function() {
        this.model().save();
        return this.fork();
      },
      isForkChanged: function() {
        var model;
        model = this.model();
        return !Imm.is(model.getCleanState(), model.getCleanState(model._stateBeforeEdit));
      }
    }
  };

  module.exports = MoreartySync;

}).call(this);
