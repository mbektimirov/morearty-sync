// Generated by CoffeeScript 1.8.0
(function() {
  var B, Binding, History, Imm, Morearty, MoreartySync, SyncModel, defaultSync, linkBinding, statusMap, validateModel, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('lodash');

  B = require('backbone');

  Imm = require('immutable');

  Morearty = require('morearty');

  Binding = Morearty.Binding, History = Morearty.History;

  linkBinding = Morearty.Callback.set;

  defaultSync = B.sync;

  statusMap = {
    'create': 'creating',
    'update': 'updating',
    'patch': 'patching',
    'delete': 'deleting',
    'read': 'reading'
  };

  B.sync = function(method, model, options) {
    var xhr;
    this.options = options != null ? options : {};
    xhr = defaultSync(method, model, options);
    if (model instanceof SyncModel) {
      model.setXhrStatus('xhr', statusMap[method]);
      return xhr.success(function() {
        return model.unsetXhrStatus('error');
      }).fail(function(e, error, errorMessage) {
        var _ref;
        if (options.rollback) {
          if ((_ref = model.history) != null) {
            _ref.undo();
          }
        }
        return model.setXhrStatus('error', e.responseJSON);
      }).always(function() {
        return model.unsetXhrStatus('xhr');
      });
    }
  };

  validateModel = function(ModelOrCollectionClass, BaseClass, type) {
    if (ModelOrCollectionClass !== BaseClass) {
      if (!(ModelOrCollectionClass.prototype instanceof BaseClass)) {
        throw new Error("" + type + " should be instance of " + BaseClass.name);
      }
    }
  };

  SyncModel = (function(_super) {
    __extends(SyncModel, _super);


    /*
    @param {Binding|Object} data - representing the model data. For raw object new binding will be created.
     */

    function SyncModel(data, options) {
      var defaults;
      if (options == null) {
        options = {};
      }
      defaults = {
        trackXhrStatus: true
      };
      this.options = _.extend(defaults, options);
      this.binding = data instanceof Binding ? data : (this.options.parse ? data = this.parse(data, this.options) || {} : void 0, Binding.init(Imm.fromJS(data)));
      Object.defineProperties(this, {
        'id': {
          writeable: false,
          get: function() {
            return this.get(this.idAttribute || 'id');
          },
          set: function(id) {
            return this.set(this.idAttribute || 'id', id);
          }
        }
      });
      this.initialize.apply(this, arguments);
    }

    SyncModel.prototype.get = function(key) {
      return this.binding.toJS(key);
    };

    SyncModel.prototype.set = function(key, val, options) {
      var attrs, k, tx, validationError, _ref;
      if (!key) {
        return this;
      }
      _ref = this._attrsAndOptions(key, val, options), attrs = _ref.attrs, options = _ref.options;
      if (_.isEmpty(attrs)) {
        return;
      }
      tx = this.binding.atomically();
      if (options.unset) {
        for (k in attrs) {
          tx["delete"](k);
        }
      } else {
        tx.merge(Imm.fromJS(attrs));
      }
      validationError = typeof this.validate === "function" ? this.validate(this.toJSON()) : void 0;
      if (validationError) {
        this.setStatus('validationError', Imm.fromJS(validationError), tx);
      } else {
        this.unsetStatus('validationError', tx);
      }
      tx.commit({
        notify: options.silent
      });
      return this;
    };

    SyncModel.prototype.clear = function(path) {
      return this.binding.clear(path);
    };

    SyncModel.prototype.toJSON = function() {
      return this.binding.toJS();
    };

    SyncModel.prototype.unsetIfExists = function(key) {
      if (this.get(key)) {
        return this.unset(key);
      }
    };

    SyncModel.prototype.bindTo = function(newBinding) {
      newBinding.set(this.binding.get());
      return this.binding = newBinding;
    };

    SyncModel.prototype.isPending = function() {
      return this.getStatus('xhr');
    };

    SyncModel.prototype.setStatus = function(key, status, tx) {
      var attrs, _ref;
      _ref = this._attrsAndOptions(key, status, tx), attrs = _ref.attrs, tx = _ref.options;
      return (!_.isEmpty(tx) ? tx : this.binding.meta()).merge(Imm.fromJS(attrs));
    };

    SyncModel.prototype.unsetStatus = function(key, tx) {
      return (!_.isEmpty(tx) ? tx : this.binding.meta())["delete"](key);
    };

    SyncModel.prototype.getStatus = function(key) {
      return this.binding.meta().get(key);
    };

    SyncModel.prototype.setXhrStatus = function(key, status) {
      if (this.options.trackXhrStatus) {
        return this.setStatus(key, status);
      }
    };

    SyncModel.prototype.unsetXhrStatus = function(key) {
      if (this.options.trackXhrStatus) {
        return this.unsetStatus(key);
      }
    };

    SyncModel.prototype._attrsAndOptions = function(key, val, options) {
      var attrs;
      attrs = {};
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        attrs[key] = val;
      }
      return {
        attrs: attrs,
        options: options || {}
      };
    };

    return SyncModel;

  })(B.Model);

  MoreartySync = {
    SyncModel: SyncModel,
    createContext: function(_arg) {
      var Ctx, ModelOrCollection, configuration, model, modelMapping, path, state, _i, _len, _ref;
      state = _arg.state, modelMapping = _arg.modelMapping, configuration = _arg.configuration;
      Ctx = Morearty.createContext(state, configuration);
      Ctx._modelMap = {};
      Ctx._modelMapRegExps = [];
      Ctx._modelInstances = {};
      for (_i = 0, _len = modelMapping.length; _i < _len; _i++) {
        _ref = modelMapping[_i], path = _ref.path, model = _ref.model;
        ModelOrCollection = model;
        if (path instanceof RegExp) {
          Ctx._modelMapRegExps.push({
            pathRegExp: path,
            model: ModelOrCollection
          });
        } else {
          Ctx._modelMap[path] = ModelOrCollection;
        }
      }
      return Ctx;
    },
    Mixin: {
      model: function(binding) {
        var MClass, ModelOrCollection, collection, ctx, itemIndex, m, matched, model, path, vectorPath, __, _ref;
        if (binding == null) {
          binding = this.getDefaultBinding();
        }
        ctx = this.context.morearty;
        path = Binding.asStringPath(binding._path);
        return model = (m = ctx._modelInstances[path]) ? m : (ModelOrCollection = ctx._modelMap[path]) ? ctx._modelInstances[path] = new ModelOrCollection(binding) : (matched = path.match(/(.*)\.(\d+)/)) ? ((__ = matched[0], vectorPath = matched[1], itemIndex = matched[2], matched), collection = ctx._modelMap[vectorPath], model = collection != null ? collection.at(itemIndex) : void 0) : (MClass = (_ref = (ctx._modelMapRegExps.filter(function(rx) {
          return path.match(rx.pathRegExp);
        }))[0]) != null ? _ref.model : void 0, MClass ? ctx._modelInstances[path] = new MClass(binding) : void 0);
      },
      collection: function(binding) {
        return this.model(binding);
      },
      linkModel: function(model, path, _arg) {
        var afterEdit, beforeEdit;
        beforeEdit = _arg.beforeEdit, afterEdit = _arg.afterEdit;
        beforeEdit || (beforeEdit = _.identity);
        afterEdit || (afterEdit = _.noop);
        return function(domEvent) {
          var value;
          value = domEvent.target.value;
          model.binding.set(path, beforeEdit(value));
          return afterEdit(value);
        };
      }
    }
  };

  module.exports = MoreartySync;

}).call(this);
