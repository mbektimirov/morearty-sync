// Generated by CoffeeScript 1.8.0
(function() {
  var B, Binding, History, Imm, Morearty, MoreartySync, SyncCollection, SyncMixin, SyncModel, attrsAndOptions, imm, linkBinding, mixOf, statusMap, validateModel, _,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('lodash');

  B = require('backbone');

  Imm = require('immutable');

  Morearty = require('morearty');

  Binding = Morearty.Binding, History = Morearty.History;

  linkBinding = Morearty.Callback.set;

  imm = Imm.fromJS;

  mixOf = function() {
    var Mixed, base, method, mixin, mixins, name, _i, _ref;
    base = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    Mixed = (function(_super) {
      __extends(Mixed, _super);

      function Mixed() {
        return Mixed.__super__.constructor.apply(this, arguments);
      }

      return Mixed;

    })(base);
    for (_i = mixins.length - 1; _i >= 0; _i += -1) {
      mixin = mixins[_i];
      _ref = mixin.prototype;
      for (name in _ref) {
        method = _ref[name];
        Mixed.prototype[name] = method;
      }
    }
    return Mixed;
  };

  attrsAndOptions = function(key, val, options) {
    var attrs;
    attrs = {};
    if (typeof key === 'object') {
      attrs = key;
      options = val;
    } else {
      attrs[key] = val;
    }
    return {
      attrs: attrs,
      options: options || {}
    };
  };

  statusMap = {
    'create': 'creating',
    'update': 'updating',
    'patch': 'patching',
    'delete': 'deleting',
    'read': 'reading'
  };

  validateModel = function(ModelOrCollectionClass, BaseClass, type) {
    if (ModelOrCollectionClass !== BaseClass) {
      if (!(ModelOrCollectionClass.prototype instanceof BaseClass)) {
        throw new Error("" + type + " should be instance of " + BaseClass.name);
      }
    }
  };

  SyncMixin = (function() {
    function SyncMixin() {}

    SyncMixin.prototype.sharedDefaults = {
      trackXhrStatus: true
    };

    SyncMixin.prototype.sync = function(method, model, options) {
      var xhr;
      if (options == null) {
        options = {};
      }
      xhr = B.sync.apply(this, arguments);
      this.setXhrStatus('xhr', statusMap[method]);
      return xhr.success((function(_this) {
        return function() {
          return _this.unsetXhrStatus('error');
        };
      })(this)).fail((function(_this) {
        return function(e, error, errorMessage) {
          var _ref;
          if (options.rollback) {
            if ((_ref = _this.history) != null) {
              _ref.undo();
            }
          }
          return _this.setXhrStatus('error', e.responseJSON);
        };
      })(this)).always((function(_this) {
        return function() {
          return _this.unsetXhrStatus('xhr');
        };
      })(this));
    };

    SyncMixin.prototype.bindTo = function(newBinding) {
      newBinding.set(this.binding.get());
      return this.binding = newBinding;
    };

    SyncMixin.prototype.isPending = function() {
      return this.getStatus('xhr');
    };

    SyncMixin.prototype.setStatus = function(key, status, tx) {
      var attrs, _ref;
      _ref = attrsAndOptions(key, status, tx), attrs = _ref.attrs, tx = _ref.options;
      return (!_.isEmpty(tx) ? tx : this.binding.meta()).merge(imm(attrs));
    };

    SyncMixin.prototype.unsetStatus = function(key, tx) {
      return (!_.isEmpty(tx) ? tx : this.binding.meta())["delete"](key);
    };

    SyncMixin.prototype.getStatus = function(key) {
      return this.binding.meta().get(key);
    };

    SyncMixin.prototype.setXhrStatus = function(key, status) {
      if (this.options.trackXhrStatus) {
        return this.setStatus(key, status);
      }
    };

    SyncMixin.prototype.unsetXhrStatus = function(key) {
      if (this.options.trackXhrStatus) {
        return this.unsetStatus(key);
      }
    };

    SyncMixin.prototype.toJSON = function() {
      return this.binding.toJS();
    };

    return SyncMixin;

  })();

  SyncModel = (function(_super) {
    __extends(SyncModel, _super);


    /*
    @param {Binding|Object} data - representing the model data. For raw object new binding will be created.
     */

    function SyncModel(data, options) {
      if (options == null) {
        options = {};
      }
      this.options = _.extend(this.sharedDefaults, options);
      this.binding = data instanceof Binding ? data : (this.options.parse ? data = this.parse(data, this.options) || {} : void 0, Binding.init(imm(data)));
      Object.defineProperties(this, {
        'id': {
          writeable: false,
          get: function() {
            return this.get(this.idAttribute || 'id');
          },
          set: function(id) {
            return this.set(this.idAttribute || 'id', id);
          }
        }
      });
      this.initialize.apply(this, arguments);
    }

    SyncModel.prototype.get = function(key) {
      return this.binding.toJS(key);
    };

    SyncModel.prototype.set = function(key, val, options) {
      var attrs, k, tx, validationError, _ref;
      if (!key) {
        return this;
      }
      _ref = attrsAndOptions(key, val, options), attrs = _ref.attrs, options = _ref.options;
      if (_.isEmpty(attrs)) {
        return;
      }
      tx = this.binding.atomically();
      if (options.unset) {
        for (k in attrs) {
          tx["delete"](k);
        }
      } else {
        tx.merge(imm(attrs));
      }
      validationError = typeof this.validate === "function" ? this.validate(this.toJSON()) : void 0;
      if (validationError) {
        this.setStatus('validationError', imm(validationError), tx);
      } else {
        this.unsetStatus('validationError', tx);
      }
      tx.commit({
        notify: options.silent
      });
      return this;
    };

    SyncModel.prototype.clear = function(path) {
      return this.binding.clear(path);
    };

    SyncModel.prototype.unsetIfExists = function(key) {
      if (this.get(key)) {
        return this.unset(key);
      }
    };

    return SyncModel;

  })(mixOf(B.Model, SyncMixin));

  SyncCollection = (function(_super) {
    __extends(SyncCollection, _super);

    SyncCollection.prototype.model = SyncModel;

    function SyncCollection(binding, options) {
      this.binding = binding;
      if (options == null) {
        options = {};
      }
      if (!(this.binding.get() instanceof Imm.List || this.binding.get() instanceof Imm.Set || this.binding.get() instanceof Imm.Stack)) {
        throw new Error('SyncCollection binding should point to Immutable.IndexedIterable (List, Set, etc.)');
      }
      this.options = _.extend(this.sharedDefaults, options);
      this.initialize.apply(this, arguments);
      validateModel(this.model, SyncModel, 'SyncCollection.model');
    }

    SyncCollection.prototype.set = function(models, options) {
      if (options == null) {
        options = {};
      }
      if (options.parse) {
        models = this.parse(models, options);
      }
      models = imm(models);
      if (options.reset) {
        return this.binding.set(models);
      } else {
        return this.binding.update(function(v) {
          return v.concat(models);
        });
      }
    };

    SyncCollection.prototype.reset = function(models, options) {
      return this.set(models, options);
    };

    SyncCollection.prototype.at = function(index) {
      return new this.model(this.binding.sub(index));
    };

    return SyncCollection;

  })(mixOf(B.Collection, SyncMixin));

  MoreartySync = {
    SyncModel: SyncModel,
    SyncCollection: SyncCollection,
    createContext: function(_arg) {
      var Ctx, ModelOrCollection, configuration, model, modelMapping, path, state, _i, _len, _ref;
      state = _arg.state, modelMapping = _arg.modelMapping, configuration = _arg.configuration;
      Ctx = Morearty.createContext(state, configuration);
      Ctx._modelMap = {};
      Ctx._modelMapRegExps = [];
      Ctx._modelInstances = {};
      for (_i = 0, _len = modelMapping.length; _i < _len; _i++) {
        _ref = modelMapping[_i], path = _ref.path, model = _ref.model;
        ModelOrCollection = model;
        if (path instanceof RegExp) {
          Ctx._modelMapRegExps.push({
            pathRegExp: path,
            model: ModelOrCollection
          });
        } else {
          Ctx._modelMap[path] = ModelOrCollection;
        }
      }
      return Ctx;
    },
    Mixin: {

      /*
      Lazy model retrieval
      @param {Binding|String} binding - binding instance or an absolute binding path
      @param {Morearty.Context} ctx - morearty context
       */
      model: function(binding, ctx) {
        var MClass, ModelOrCollection, collection, itemIndex, m, matched, model, path, vectorPath, __, _ref, _ref1;
        if (binding == null) {
          binding = this.getDefaultBinding();
        }
        if (ctx == null) {
          ctx = this.context.morearty;
        }
        _ref = binding instanceof Binding ? {
          binding: binding,
          path: Binding.asStringPath(binding._path)
        } : (path = binding, {
          binding: ctx.getBinding().sub(path),
          path: path
        }), binding = _ref.binding, path = _ref.path;
        return model = (m = ctx._modelInstances[path]) ? m : (ModelOrCollection = ctx._modelMap[path]) ? ctx._modelInstances[path] = new ModelOrCollection(binding) : (matched = path.match(/(.*)\.(\d+)/)) ? ((__ = matched[0], vectorPath = matched[1], itemIndex = matched[2], matched), collection = ctx._modelMap[vectorPath], model = collection != null ? collection.at(itemIndex) : void 0) : (MClass = (_ref1 = (ctx._modelMapRegExps.filter(function(rx) {
          return path.match(rx.pathRegExp);
        }))[0]) != null ? _ref1.model : void 0, MClass ? ctx._modelInstances[path] = new MClass(binding) : void 0);
      },
      collection: function(binding, ctx) {
        return this.model(binding, ctx);
      },
      linkModel: function(model, path, _arg) {
        var afterEdit, beforeEdit;
        beforeEdit = _arg.beforeEdit, afterEdit = _arg.afterEdit;
        beforeEdit || (beforeEdit = _.identity);
        afterEdit || (afterEdit = _.noop);
        return function(domEvent) {
          var value;
          value = domEvent.target.value;
          model.binding.set(path, beforeEdit(value));
          return afterEdit(value);
        };
      }
    }
  };

  module.exports = MoreartySync;

}).call(this);
